/**
 * Autogenerated by Scrooge
 * Edit this shit, I dare you.
 */

package ciir.aura.proteus

import java.net.InetSocketAddress
import java.nio.ByteBuffer
import java.util.Arrays
import scala.collection.{Map, Set}
import scala.collection.mutable
import com.twitter.conversions.time._
import com.twitter.finagle.SourcedException
import com.twitter.scrooge.{ThriftStruct, ThriftStructCodec}
import com.twitter.util.Future
import org.apache.thrift.TApplicationException
import org.apache.thrift.TEnum
import org.apache.thrift.protocol._
import org.apache.thrift.transport.{TMemoryInputTransport, TMemoryBuffer}

// ----- enums

object ProteusType {
  case object Collection extends ProteusType(0, "Collection")
  case object Page extends ProteusType(1, "Page")
  case object Picture extends ProteusType(2, "Picture")
  case object Video extends ProteusType(3, "Video")
  case object Audio extends ProteusType(4, "Audio")
  case object Person extends ProteusType(5, "Person")
  case object Location extends ProteusType(6, "Location")
  case object Organization extends ProteusType(7, "Organization")

  def apply(value: Int): ProteusType = {
    value match {
      case 0 => Collection
      case 1 => Page
      case 2 => Picture
      case 3 => Video
      case 4 => Audio
      case 5 => Person
      case 6 => Location
      case 7 => Organization
      case _ => throw new NoSuchElementException(value.toString)
    }
  }

  def get(value: Int): Option[ProteusType] = {
    value match {
      case 0 => scala.Some(Collection)
      case 1 => scala.Some(Page)
      case 2 => scala.Some(Picture)
      case 3 => scala.Some(Video)
      case 4 => scala.Some(Audio)
      case 5 => scala.Some(Person)
      case 6 => scala.Some(Location)
      case 7 => scala.Some(Organization)
      case _ => scala.None
    }
  }

  def valueOf(name: String): Option[ProteusType] = {
    name.toLowerCase match {
      case "collection" => scala.Some(ProteusType.Collection)
      case "page" => scala.Some(ProteusType.Page)
      case "picture" => scala.Some(ProteusType.Picture)
      case "video" => scala.Some(ProteusType.Video)
      case "audio" => scala.Some(ProteusType.Audio)
      case "person" => scala.Some(ProteusType.Person)
      case "location" => scala.Some(ProteusType.Location)
      case "organization" => scala.Some(ProteusType.Organization)
      case _ => scala.None
    }
  }
}

abstract class ProteusType(val value: Int, val name: String) extends TEnum {
  def getValue = value
}

object TransformType {
  case object ToContainer extends TransformType(0, "ToContainer")
  case object ToContents extends TransformType(1, "ToContents")
  case object Overlap extends TransformType(2, "Overlap")
  case object ObjectOf extends TransformType(3, "ObjectOf")
  case object SubjectOf extends TransformType(4, "SubjectOf")
  case object HasAsObject extends TransformType(5, "HasAsObject")
  case object HasAsSubject extends TransformType(6, "HasAsSubject")
  case object GeographicProx extends TransformType(7, "GeographicProx")

  def apply(value: Int): TransformType = {
    value match {
      case 0 => ToContainer
      case 1 => ToContents
      case 2 => Overlap
      case 3 => ObjectOf
      case 4 => SubjectOf
      case 5 => HasAsObject
      case 6 => HasAsSubject
      case 7 => GeographicProx
      case _ => throw new NoSuchElementException(value.toString)
    }
  }

  def get(value: Int): Option[TransformType] = {
    value match {
      case 0 => scala.Some(ToContainer)
      case 1 => scala.Some(ToContents)
      case 2 => scala.Some(Overlap)
      case 3 => scala.Some(ObjectOf)
      case 4 => scala.Some(SubjectOf)
      case 5 => scala.Some(HasAsObject)
      case 6 => scala.Some(HasAsSubject)
      case 7 => scala.Some(GeographicProx)
      case _ => scala.None
    }
  }

  def valueOf(name: String): Option[TransformType] = {
    name.toLowerCase match {
      case "tocontainer" => scala.Some(TransformType.ToContainer)
      case "tocontents" => scala.Some(TransformType.ToContents)
      case "overlap" => scala.Some(TransformType.Overlap)
      case "objectof" => scala.Some(TransformType.ObjectOf)
      case "subjectof" => scala.Some(TransformType.SubjectOf)
      case "hasasobject" => scala.Some(TransformType.HasAsObject)
      case "hasassubject" => scala.Some(TransformType.HasAsSubject)
      case "geographicprox" => scala.Some(TransformType.GeographicProx)
      case _ => scala.None
    }
  }
}

abstract class TransformType(val value: Int, val name: String) extends TEnum {
  def getValue = value
}

// ----- AccessIdentifier

object AccessIdentifier extends ThriftStructCodec[AccessIdentifier] {
  val STRUCT_DESC = new TStruct("AccessIdentifier")
  val IDENTIFIER_FIELD_DESC = new TField("identifier", TType.STRING, 1)
  val TYPE_FIELD_DESC = new TField("type", TType.I32, 2)
  val RESOURCEID_FIELD_DESC = new TField("resourceId", TType.STRING, 3)
  val ERROR_FIELD_DESC = new TField("error", TType.STRING, 4)

  val decoder = { (_iprot: TProtocol) =>
    var `identifier`: String = null
    var `type`: ProteusType = null
    var `resourceId`: String = null
    var `error`: Option[String] = None

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* identifier */
            _field.`type` match {
              case TType.STRING => {
                `identifier` = {
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* type */
            _field.`type` match {
              case TType.I32 => {
                `type` = {
                  ProteusType(_iprot.readI32())
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 3 => { /* resourceId */
            _field.`type` match {
              case TType.STRING => {
                `resourceId` = {
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 4 => { /* error */
            _field.`type` match {
              case TType.STRING => {
                `error` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    AccessIdentifier(`identifier`, `type`, `resourceId`, `error`)
  }

  val encoder = { (_item: AccessIdentifier, _oproto: TProtocol) => _item.write(_oproto) }

}

case class AccessIdentifier(`identifier`: String, `type`: ProteusType, `resourceId`: String, `error`: Option[String] = None) extends ThriftStruct {
  import AccessIdentifier._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`identifier` ne null) {
      val _item = `identifier`
      _oprot.writeFieldBegin(IDENTIFIER_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`type` ne null) {
      val _item = `type`
      _oprot.writeFieldBegin(TYPE_FIELD_DESC)
      _oprot.writeI32(_item.value)
      _oprot.writeFieldEnd()
    }
    if (`resourceId` ne null) {
      val _item = `resourceId`
      _oprot.writeFieldBegin(RESOURCEID_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`error`.isDefined) {
      val _item = `error`.get
      _oprot.writeFieldBegin(ERROR_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- RequestParameters

object RequestParameters extends ThriftStructCodec[RequestParameters] {
  val STRUCT_DESC = new TStruct("RequestParameters")
  val NUMRESULTSREQUESTED_FIELD_DESC = new TField("numResultsRequested", TType.I32, 1)
  val STARTAT_FIELD_DESC = new TField("startAt", TType.I32, 2)
  val LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 3)

  val decoder = { (_iprot: TProtocol) =>
    var `numResultsRequested`: Int = 0
    var `startAt`: Int = 0
    var `language`: String = null

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* numResultsRequested */
            _field.`type` match {
              case TType.I32 => {
                `numResultsRequested` = {
                  _iprot.readI32()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* startAt */
            _field.`type` match {
              case TType.I32 => {
                `startAt` = {
                  _iprot.readI32()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 3 => { /* language */
            _field.`type` match {
              case TType.STRING => {
                `language` = {
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    RequestParameters(`numResultsRequested`, `startAt`, `language`)
  }

  val encoder = { (_item: RequestParameters, _oproto: TProtocol) => _item.write(_oproto) }

}

case class RequestParameters(`numResultsRequested`: Int = 10, `startAt`: Int = 0, `language`: String = "en") extends ThriftStruct {
  import RequestParameters._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (true) {
      val _item = `numResultsRequested`
      _oprot.writeFieldBegin(NUMRESULTSREQUESTED_FIELD_DESC)
      _oprot.writeI32(_item)
      _oprot.writeFieldEnd()
    }
    if (true) {
      val _item = `startAt`
      _oprot.writeFieldBegin(STARTAT_FIELD_DESC)
      _oprot.writeI32(_item)
      _oprot.writeFieldEnd()
    }
    if (`language` ne null) {
      val _item = `language`
      _oprot.writeFieldBegin(LANGUAGE_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- SearchRequest

object SearchRequest extends ThriftStructCodec[SearchRequest] {
  val STRUCT_DESC = new TStruct("SearchRequest")
  val RAWQUERY_FIELD_DESC = new TField("rawQuery", TType.STRING, 1)
  val TYPES_FIELD_DESC = new TField("types", TType.LIST, 2)
  val PARAMETERS_FIELD_DESC = new TField("parameters", TType.STRUCT, 3)

  val decoder = { (_iprot: TProtocol) =>
    var `rawQuery`: String = null
    var `types`: Seq[ProteusType] = null
    var `parameters`: Option[RequestParameters] = None

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* rawQuery */
            _field.`type` match {
              case TType.STRING => {
                `rawQuery` = {
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* types */
            _field.`type` match {
              case TType.LIST => {
                `types` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[ProteusType](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      ProteusType(_iprot.readI32())
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 3 => { /* parameters */
            _field.`type` match {
              case TType.STRUCT => {
                `parameters` = Some{
                  RequestParameters.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    SearchRequest(`rawQuery`, `types`, `parameters`)
  }

  val encoder = { (_item: SearchRequest, _oproto: TProtocol) => _item.write(_oproto) }

}

case class SearchRequest(`rawQuery`: String, `types`: Seq[ProteusType], `parameters`: Option[RequestParameters] = None) extends ThriftStruct {
  import SearchRequest._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`rawQuery` ne null) {
      val _item = `rawQuery`
      _oprot.writeFieldBegin(RAWQUERY_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`types` ne null) {
      val _item = `types`
      _oprot.writeFieldBegin(TYPES_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.I32, _item.size))
      _item.foreach { _item =>
        _oprot.writeI32(_item.value)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    if (`parameters`.isDefined) {
      val _item = `parameters`.get
      _oprot.writeFieldBegin(PARAMETERS_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- WeightedDate

object WeightedDate extends ThriftStructCodec[WeightedDate] {
  val STRUCT_DESC = new TStruct("WeightedDate")
  val DATE_FIELD_DESC = new TField("date", TType.I64, 1)
  val WEIGHT_FIELD_DESC = new TField("weight", TType.DOUBLE, 2)

  val decoder = { (_iprot: TProtocol) =>
    var `date`: Long = 0
    var `weight`: Double = 0.0

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* date */
            _field.`type` match {
              case TType.I64 => {
                `date` = {
                  _iprot.readI64()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* weight */
            _field.`type` match {
              case TType.DOUBLE => {
                `weight` = {
                  _iprot.readDouble()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    WeightedDate(`date`, `weight`)
  }

  val encoder = { (_item: WeightedDate, _oproto: TProtocol) => _item.write(_oproto) }

}

case class WeightedDate(`date`: Long, `weight`: Double = 1.0) extends ThriftStruct {
  import WeightedDate._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (true) {
      val _item = `date`
      _oprot.writeFieldBegin(DATE_FIELD_DESC)
      _oprot.writeI64(_item)
      _oprot.writeFieldEnd()
    }
    if (true) {
      val _item = `weight`
      _oprot.writeFieldBegin(WEIGHT_FIELD_DESC)
      _oprot.writeDouble(_item)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- TextRegion

object TextRegion extends ThriftStructCodec[TextRegion] {
  val STRUCT_DESC = new TStruct("TextRegion")
  val START_FIELD_DESC = new TField("start", TType.I32, 1)
  val STOP_FIELD_DESC = new TField("stop", TType.I32, 2)

  val decoder = { (_iprot: TProtocol) =>
    var `start`: Int = 0
    var `stop`: Int = 0

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* start */
            _field.`type` match {
              case TType.I32 => {
                `start` = {
                  _iprot.readI32()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* stop */
            _field.`type` match {
              case TType.I32 => {
                `stop` = {
                  _iprot.readI32()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    TextRegion(`start`, `stop`)
  }

  val encoder = { (_item: TextRegion, _oproto: TProtocol) => _item.write(_oproto) }

}

case class TextRegion(`start`: Int, `stop`: Int) extends ThriftStruct {
  import TextRegion._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (true) {
      val _item = `start`
      _oprot.writeFieldBegin(START_FIELD_DESC)
      _oprot.writeI32(_item)
      _oprot.writeFieldEnd()
    }
    if (true) {
      val _item = `stop`
      _oprot.writeFieldBegin(STOP_FIELD_DESC)
      _oprot.writeI32(_item)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- ResultSummary

object ResultSummary extends ThriftStructCodec[ResultSummary] {
  val STRUCT_DESC = new TStruct("ResultSummary")
  val TEXT_FIELD_DESC = new TField("text", TType.STRING, 1)
  val HIGHLIGHTS_FIELD_DESC = new TField("highlights", TType.LIST, 2)

  val decoder = { (_iprot: TProtocol) =>
    var `text`: String = null
    var `highlights`: Seq[TextRegion] = null

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* text */
            _field.`type` match {
              case TType.STRING => {
                `text` = {
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* highlights */
            _field.`type` match {
              case TType.LIST => {
                `highlights` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[TextRegion](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      TextRegion.decoder(_iprot)
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    ResultSummary(`text`, `highlights`)
  }

  val encoder = { (_item: ResultSummary, _oproto: TProtocol) => _item.write(_oproto) }

}

case class ResultSummary(`text`: String, `highlights`: Seq[TextRegion]) extends ThriftStruct {
  import ResultSummary._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`text` ne null) {
      val _item = `text`
      _oprot.writeFieldBegin(TEXT_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`highlights` ne null) {
      val _item = `highlights`
      _oprot.writeFieldBegin(HIGHLIGHTS_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.STRUCT, _item.size))
      _item.foreach { _item =>
        _item.write(_oprot)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- SearchResult

object SearchResult extends ThriftStructCodec[SearchResult] {
  val STRUCT_DESC = new TStruct("SearchResult")
  val ID_FIELD_DESC = new TField("id", TType.STRUCT, 1)
  val TITLE_FIELD_DESC = new TField("title", TType.STRING, 2)
  val SUMMARY_FIELD_DESC = new TField("summary", TType.STRUCT, 3)
  val IMGURL_FIELD_DESC = new TField("imgUrl", TType.STRING, 4)
  val THUMBURL_FIELD_DESC = new TField("thumbUrl", TType.STRING, 5)
  val EXTERNALURL_FIELD_DESC = new TField("externalUrl", TType.STRING, 6)

  val decoder = { (_iprot: TProtocol) =>
    var `id`: AccessIdentifier = null
    var `title`: Option[String] = None
    var `summary`: Option[ResultSummary] = None
    var `imgUrl`: Option[String] = None
    var `thumbUrl`: Option[String] = None
    var `externalUrl`: Option[String] = None

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* id */
            _field.`type` match {
              case TType.STRUCT => {
                `id` = {
                  AccessIdentifier.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* title */
            _field.`type` match {
              case TType.STRING => {
                `title` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 3 => { /* summary */
            _field.`type` match {
              case TType.STRUCT => {
                `summary` = Some{
                  ResultSummary.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 4 => { /* imgUrl */
            _field.`type` match {
              case TType.STRING => {
                `imgUrl` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 5 => { /* thumbUrl */
            _field.`type` match {
              case TType.STRING => {
                `thumbUrl` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 6 => { /* externalUrl */
            _field.`type` match {
              case TType.STRING => {
                `externalUrl` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    SearchResult(`id`, `title`, `summary`, `imgUrl`, `thumbUrl`, `externalUrl`)
  }

  val encoder = { (_item: SearchResult, _oproto: TProtocol) => _item.write(_oproto) }

}

case class SearchResult(`id`: AccessIdentifier, `title`: Option[String] = None, `summary`: Option[ResultSummary] = None, `imgUrl`: Option[String] = None, `thumbUrl`: Option[String] = None, `externalUrl`: Option[String] = None) extends ThriftStruct {
  import SearchResult._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`id` ne null) {
      val _item = `id`
      _oprot.writeFieldBegin(ID_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`title`.isDefined) {
      val _item = `title`.get
      _oprot.writeFieldBegin(TITLE_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`summary`.isDefined) {
      val _item = `summary`.get
      _oprot.writeFieldBegin(SUMMARY_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`imgUrl`.isDefined) {
      val _item = `imgUrl`.get
      _oprot.writeFieldBegin(IMGURL_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`thumbUrl`.isDefined) {
      val _item = `thumbUrl`.get
      _oprot.writeFieldBegin(THUMBURL_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`externalUrl`.isDefined) {
      val _item = `externalUrl`.get
      _oprot.writeFieldBegin(EXTERNALURL_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- SearchResponse

object SearchResponse extends ThriftStructCodec[SearchResponse] {
  val STRUCT_DESC = new TStruct("SearchResponse")
  val RESULTS_FIELD_DESC = new TField("results", TType.LIST, 1)
  val ERROR_FIELD_DESC = new TField("error", TType.STRING, 2)

  val decoder = { (_iprot: TProtocol) =>
    var `results`: Seq[SearchResult] = null
    var `error`: Option[String] = None

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* results */
            _field.`type` match {
              case TType.LIST => {
                `results` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[SearchResult](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      SearchResult.decoder(_iprot)
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* error */
            _field.`type` match {
              case TType.STRING => {
                `error` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    SearchResponse(`results`, `error`)
  }

  val encoder = { (_item: SearchResponse, _oproto: TProtocol) => _item.write(_oproto) }

}

case class SearchResponse(`results`: Seq[SearchResult], `error`: Option[String] = None) extends ThriftStruct {
  import SearchResponse._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`results` ne null) {
      val _item = `results`
      _oprot.writeFieldBegin(RESULTS_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.STRUCT, _item.size))
      _item.foreach { _item =>
        _item.write(_oprot)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    if (`error`.isDefined) {
      val _item = `error`.get
      _oprot.writeFieldBegin(ERROR_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- WeightedTerm

object WeightedTerm extends ThriftStructCodec[WeightedTerm] {
  val STRUCT_DESC = new TStruct("WeightedTerm")
  val TERM_FIELD_DESC = new TField("term", TType.STRING, 1)
  val WEIGHT_FIELD_DESC = new TField("weight", TType.DOUBLE, 2)

  val decoder = { (_iprot: TProtocol) =>
    var `term`: String = null
    var `weight`: Double = 0.0

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* term */
            _field.`type` match {
              case TType.STRING => {
                `term` = {
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* weight */
            _field.`type` match {
              case TType.DOUBLE => {
                `weight` = {
                  _iprot.readDouble()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    WeightedTerm(`term`, `weight`)
  }

  val encoder = { (_item: WeightedTerm, _oproto: TProtocol) => _item.write(_oproto) }

}

case class WeightedTerm(`term`: String, `weight`: Double = 1.0) extends ThriftStruct {
  import WeightedTerm._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`term` ne null) {
      val _item = `term`
      _oprot.writeFieldBegin(TERM_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (true) {
      val _item = `weight`
      _oprot.writeFieldBegin(WEIGHT_FIELD_DESC)
      _oprot.writeDouble(_item)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- TermHistogram

object TermHistogram extends ThriftStructCodec[TermHistogram] {
  val STRUCT_DESC = new TStruct("TermHistogram")
  val TERMS_FIELD_DESC = new TField("terms", TType.LIST, 1)

  val decoder = { (_iprot: TProtocol) =>
    var `terms`: Seq[WeightedTerm] = null

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* terms */
            _field.`type` match {
              case TType.LIST => {
                `terms` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[WeightedTerm](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      WeightedTerm.decoder(_iprot)
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    TermHistogram(`terms`)
  }

  val encoder = { (_item: TermHistogram, _oproto: TProtocol) => _item.write(_oproto) }

}

case class TermHistogram(`terms`: Seq[WeightedTerm]) extends ThriftStruct {
  import TermHistogram._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`terms` ne null) {
      val _item = `terms`
      _oprot.writeFieldBegin(TERMS_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.STRUCT, _item.size))
      _item.foreach { _item =>
        _item.write(_oprot)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- Organization

object Organization extends ThriftStructCodec[Organization] {
  val STRUCT_DESC = new TStruct("Organization")
  val FULLNAME_FIELD_DESC = new TField("fullName", TType.STRING, 1)
  val ALTERNATENAMES_FIELD_DESC = new TField("alternateNames", TType.LIST, 2)
  val WIKILINK_FIELD_DESC = new TField("wikiLink", TType.STRING, 3)

  val decoder = { (_iprot: TProtocol) =>
    var `fullName`: Option[String] = None
    var `alternateNames`: Seq[String] = null
    var `wikiLink`: Option[String] = None

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* fullName */
            _field.`type` match {
              case TType.STRING => {
                `fullName` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* alternateNames */
            _field.`type` match {
              case TType.LIST => {
                `alternateNames` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[String](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      _iprot.readString()
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 3 => { /* wikiLink */
            _field.`type` match {
              case TType.STRING => {
                `wikiLink` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    Organization(`fullName`, `alternateNames`, `wikiLink`)
  }

  val encoder = { (_item: Organization, _oproto: TProtocol) => _item.write(_oproto) }

}

case class Organization(`fullName`: Option[String] = None, `alternateNames`: Seq[String], `wikiLink`: Option[String] = None) extends ThriftStruct {
  import Organization._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`fullName`.isDefined) {
      val _item = `fullName`.get
      _oprot.writeFieldBegin(FULLNAME_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`alternateNames` ne null) {
      val _item = `alternateNames`
      _oprot.writeFieldBegin(ALTERNATENAMES_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.STRING, _item.size))
      _item.foreach { _item =>
        _oprot.writeString(_item)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    if (`wikiLink`.isDefined) {
      val _item = `wikiLink`.get
      _oprot.writeFieldBegin(WIKILINK_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- LongValueHistogram

object LongValueHistogram extends ThriftStructCodec[LongValueHistogram] {
  val STRUCT_DESC = new TStruct("LongValueHistogram")
  val DATES_FIELD_DESC = new TField("dates", TType.LIST, 1)

  val decoder = { (_iprot: TProtocol) =>
    var `dates`: Seq[WeightedDate] = null

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* dates */
            _field.`type` match {
              case TType.LIST => {
                `dates` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[WeightedDate](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      WeightedDate.decoder(_iprot)
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    LongValueHistogram(`dates`)
  }

  val encoder = { (_item: LongValueHistogram, _oproto: TProtocol) => _item.write(_oproto) }

}

case class LongValueHistogram(`dates`: Seq[WeightedDate]) extends ThriftStruct {
  import LongValueHistogram._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`dates` ne null) {
      val _item = `dates`
      _oprot.writeFieldBegin(DATES_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.STRUCT, _item.size))
      _item.foreach { _item =>
        _item.write(_oprot)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- Collection

object Collection extends ThriftStructCodec[Collection] {
  val STRUCT_DESC = new TStruct("Collection")
  val PUBLICATIONDATE_FIELD_DESC = new TField("publicationDate", TType.I64, 1)
  val PUBLISHER_FIELD_DESC = new TField("publisher", TType.STRING, 2)
  val EDITION_FIELD_DESC = new TField("edition", TType.STRING, 3)
  val NUMPAGES_FIELD_DESC = new TField("numPages", TType.I32, 4)
  val CREATORS_FIELD_DESC = new TField("creators", TType.LIST, 5)

  val decoder = { (_iprot: TProtocol) =>
    var `publicationDate`: Option[Long] = None
    var `publisher`: Option[String] = None
    var `edition`: Option[String] = None
    var `numPages`: Option[Int] = None
    var `creators`: Seq[String] = null

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* publicationDate */
            _field.`type` match {
              case TType.I64 => {
                `publicationDate` = Some{
                  _iprot.readI64()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* publisher */
            _field.`type` match {
              case TType.STRING => {
                `publisher` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 3 => { /* edition */
            _field.`type` match {
              case TType.STRING => {
                `edition` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 4 => { /* numPages */
            _field.`type` match {
              case TType.I32 => {
                `numPages` = Some{
                  _iprot.readI32()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 5 => { /* creators */
            _field.`type` match {
              case TType.LIST => {
                `creators` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[String](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      _iprot.readString()
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    Collection(`publicationDate`, `publisher`, `edition`, `numPages`, `creators`)
  }

  val encoder = { (_item: Collection, _oproto: TProtocol) => _item.write(_oproto) }

}

case class Collection(`publicationDate`: Option[Long] = None, `publisher`: Option[String] = None, `edition`: Option[String] = None, `numPages`: Option[Int] = None, `creators`: Seq[String]) extends ThriftStruct {
  import Collection._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`publicationDate`.isDefined) {
      val _item = `publicationDate`.get
      _oprot.writeFieldBegin(PUBLICATIONDATE_FIELD_DESC)
      _oprot.writeI64(_item)
      _oprot.writeFieldEnd()
    }
    if (`publisher`.isDefined) {
      val _item = `publisher`.get
      _oprot.writeFieldBegin(PUBLISHER_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`edition`.isDefined) {
      val _item = `edition`.get
      _oprot.writeFieldBegin(EDITION_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`numPages`.isDefined) {
      val _item = `numPages`.get
      _oprot.writeFieldBegin(NUMPAGES_FIELD_DESC)
      _oprot.writeI32(_item)
      _oprot.writeFieldEnd()
    }
    if (`creators` ne null) {
      val _item = `creators`
      _oprot.writeFieldBegin(CREATORS_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.STRING, _item.size))
      _item.foreach { _item =>
        _oprot.writeString(_item)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- Page

object Page extends ThriftStructCodec[Page] {
  val STRUCT_DESC = new TStruct("Page")
  val FULLTEXT_FIELD_DESC = new TField("fullText", TType.STRING, 1)
  val CREATORS_FIELD_DESC = new TField("creators", TType.LIST, 2)
  val PAGENUMBER_FIELD_DESC = new TField("pageNumber", TType.I32, 3)

  val decoder = { (_iprot: TProtocol) =>
    var `fullText`: Option[String] = None
    var `creators`: Seq[String] = null
    var `pageNumber`: Option[Int] = None

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* fullText */
            _field.`type` match {
              case TType.STRING => {
                `fullText` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* creators */
            _field.`type` match {
              case TType.LIST => {
                `creators` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[String](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      _iprot.readString()
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 3 => { /* pageNumber */
            _field.`type` match {
              case TType.I32 => {
                `pageNumber` = Some{
                  _iprot.readI32()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    Page(`fullText`, `creators`, `pageNumber`)
  }

  val encoder = { (_item: Page, _oproto: TProtocol) => _item.write(_oproto) }

}

case class Page(`fullText`: Option[String] = None, `creators`: Seq[String], `pageNumber`: Option[Int] = None) extends ThriftStruct {
  import Page._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`fullText`.isDefined) {
      val _item = `fullText`.get
      _oprot.writeFieldBegin(FULLTEXT_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`creators` ne null) {
      val _item = `creators`
      _oprot.writeFieldBegin(CREATORS_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.STRING, _item.size))
      _item.foreach { _item =>
        _oprot.writeString(_item)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    if (`pageNumber`.isDefined) {
      val _item = `pageNumber`.get
      _oprot.writeFieldBegin(PAGENUMBER_FIELD_DESC)
      _oprot.writeI32(_item)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- Coordinates

object Coordinates extends ThriftStructCodec[Coordinates] {
  val STRUCT_DESC = new TStruct("Coordinates")
  val LEFT_FIELD_DESC = new TField("left", TType.I32, 1)
  val RIGHT_FIELD_DESC = new TField("right", TType.I32, 2)
  val TOP_FIELD_DESC = new TField("top", TType.I32, 3)
  val BOTTOM_FIELD_DESC = new TField("bottom", TType.I32, 4)

  val decoder = { (_iprot: TProtocol) =>
    var `left`: Int = 0
    var `right`: Int = 0
    var `top`: Int = 0
    var `bottom`: Int = 0

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* left */
            _field.`type` match {
              case TType.I32 => {
                `left` = {
                  _iprot.readI32()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* right */
            _field.`type` match {
              case TType.I32 => {
                `right` = {
                  _iprot.readI32()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 3 => { /* top */
            _field.`type` match {
              case TType.I32 => {
                `top` = {
                  _iprot.readI32()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 4 => { /* bottom */
            _field.`type` match {
              case TType.I32 => {
                `bottom` = {
                  _iprot.readI32()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    Coordinates(`left`, `right`, `top`, `bottom`)
  }

  val encoder = { (_item: Coordinates, _oproto: TProtocol) => _item.write(_oproto) }

}

case class Coordinates(`left`: Int, `right`: Int, `top`: Int, `bottom`: Int) extends ThriftStruct {
  import Coordinates._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (true) {
      val _item = `left`
      _oprot.writeFieldBegin(LEFT_FIELD_DESC)
      _oprot.writeI32(_item)
      _oprot.writeFieldEnd()
    }
    if (true) {
      val _item = `right`
      _oprot.writeFieldBegin(RIGHT_FIELD_DESC)
      _oprot.writeI32(_item)
      _oprot.writeFieldEnd()
    }
    if (true) {
      val _item = `top`
      _oprot.writeFieldBegin(TOP_FIELD_DESC)
      _oprot.writeI32(_item)
      _oprot.writeFieldEnd()
    }
    if (true) {
      val _item = `bottom`
      _oprot.writeFieldBegin(BOTTOM_FIELD_DESC)
      _oprot.writeI32(_item)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- Audio

object Audio extends ThriftStructCodec[Audio] {
  val STRUCT_DESC = new TStruct("Audio")
  val CAPTION_FIELD_DESC = new TField("caption", TType.STRING, 1)
  val COORDINATES_FIELD_DESC = new TField("coordinates", TType.STRUCT, 2)
  val LENGTH_FIELD_DESC = new TField("length", TType.I32, 3)
  val CREATORS_FIELD_DESC = new TField("creators", TType.LIST, 4)

  val decoder = { (_iprot: TProtocol) =>
    var `caption`: Option[String] = None
    var `coordinates`: Option[Coordinates] = None
    var `length`: Option[Int] = None
    var `creators`: Seq[String] = null

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* caption */
            _field.`type` match {
              case TType.STRING => {
                `caption` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* coordinates */
            _field.`type` match {
              case TType.STRUCT => {
                `coordinates` = Some{
                  Coordinates.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 3 => { /* length */
            _field.`type` match {
              case TType.I32 => {
                `length` = Some{
                  _iprot.readI32()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 4 => { /* creators */
            _field.`type` match {
              case TType.LIST => {
                `creators` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[String](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      _iprot.readString()
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    Audio(`caption`, `coordinates`, `length`, `creators`)
  }

  val encoder = { (_item: Audio, _oproto: TProtocol) => _item.write(_oproto) }

}

case class Audio(`caption`: Option[String] = None, `coordinates`: Option[Coordinates] = None, `length`: Option[Int] = None, `creators`: Seq[String]) extends ThriftStruct {
  import Audio._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`caption`.isDefined) {
      val _item = `caption`.get
      _oprot.writeFieldBegin(CAPTION_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`coordinates`.isDefined) {
      val _item = `coordinates`.get
      _oprot.writeFieldBegin(COORDINATES_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`length`.isDefined) {
      val _item = `length`.get
      _oprot.writeFieldBegin(LENGTH_FIELD_DESC)
      _oprot.writeI32(_item)
      _oprot.writeFieldEnd()
    }
    if (`creators` ne null) {
      val _item = `creators`
      _oprot.writeFieldBegin(CREATORS_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.STRING, _item.size))
      _item.foreach { _item =>
        _oprot.writeString(_item)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- Picture

object Picture extends ThriftStructCodec[Picture] {
  val STRUCT_DESC = new TStruct("Picture")
  val CAPTION_FIELD_DESC = new TField("caption", TType.STRING, 1)
  val COORDINATES_FIELD_DESC = new TField("coordinates", TType.STRUCT, 2)
  val CREATORS_FIELD_DESC = new TField("creators", TType.LIST, 3)

  val decoder = { (_iprot: TProtocol) =>
    var `caption`: Option[String] = None
    var `coordinates`: Option[Coordinates] = None
    var `creators`: Seq[String] = null

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* caption */
            _field.`type` match {
              case TType.STRING => {
                `caption` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* coordinates */
            _field.`type` match {
              case TType.STRUCT => {
                `coordinates` = Some{
                  Coordinates.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 3 => { /* creators */
            _field.`type` match {
              case TType.LIST => {
                `creators` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[String](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      _iprot.readString()
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    Picture(`caption`, `coordinates`, `creators`)
  }

  val encoder = { (_item: Picture, _oproto: TProtocol) => _item.write(_oproto) }

}

case class Picture(`caption`: Option[String] = None, `coordinates`: Option[Coordinates] = None, `creators`: Seq[String]) extends ThriftStruct {
  import Picture._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`caption`.isDefined) {
      val _item = `caption`.get
      _oprot.writeFieldBegin(CAPTION_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`coordinates`.isDefined) {
      val _item = `coordinates`.get
      _oprot.writeFieldBegin(COORDINATES_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`creators` ne null) {
      val _item = `creators`
      _oprot.writeFieldBegin(CREATORS_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.STRING, _item.size))
      _item.foreach { _item =>
        _oprot.writeString(_item)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- Video

object Video extends ThriftStructCodec[Video] {
  val STRUCT_DESC = new TStruct("Video")
  val CAPTION_FIELD_DESC = new TField("caption", TType.STRING, 1)
  val COORDINATES_FIELD_DESC = new TField("coordinates", TType.STRUCT, 2)
  val LENGTHINSECONDS_FIELD_DESC = new TField("lengthInSeconds", TType.I32, 3)
  val CREATORS_FIELD_DESC = new TField("creators", TType.LIST, 4)

  val decoder = { (_iprot: TProtocol) =>
    var `caption`: Option[String] = None
    var `coordinates`: Option[Coordinates] = None
    var `lengthInSeconds`: Option[Int] = None
    var `creators`: Seq[String] = null

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* caption */
            _field.`type` match {
              case TType.STRING => {
                `caption` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* coordinates */
            _field.`type` match {
              case TType.STRUCT => {
                `coordinates` = Some{
                  Coordinates.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 3 => { /* lengthInSeconds */
            _field.`type` match {
              case TType.I32 => {
                `lengthInSeconds` = Some{
                  _iprot.readI32()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 4 => { /* creators */
            _field.`type` match {
              case TType.LIST => {
                `creators` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[String](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      _iprot.readString()
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    Video(`caption`, `coordinates`, `lengthInSeconds`, `creators`)
  }

  val encoder = { (_item: Video, _oproto: TProtocol) => _item.write(_oproto) }

}

case class Video(`caption`: Option[String] = None, `coordinates`: Option[Coordinates] = None, `lengthInSeconds`: Option[Int] = None, `creators`: Seq[String]) extends ThriftStruct {
  import Video._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`caption`.isDefined) {
      val _item = `caption`.get
      _oprot.writeFieldBegin(CAPTION_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`coordinates`.isDefined) {
      val _item = `coordinates`.get
      _oprot.writeFieldBegin(COORDINATES_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`lengthInSeconds`.isDefined) {
      val _item = `lengthInSeconds`.get
      _oprot.writeFieldBegin(LENGTHINSECONDS_FIELD_DESC)
      _oprot.writeI32(_item)
      _oprot.writeFieldEnd()
    }
    if (`creators` ne null) {
      val _item = `creators`
      _oprot.writeFieldBegin(CREATORS_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.STRING, _item.size))
      _item.foreach { _item =>
        _oprot.writeString(_item)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- Person

object Person extends ThriftStructCodec[Person] {
  val STRUCT_DESC = new TStruct("Person")
  val FULLNAME_FIELD_DESC = new TField("fullName", TType.STRING, 1)
  val ALTERNATENAMES_FIELD_DESC = new TField("alternateNames", TType.LIST, 2)
  val WIKILINK_FIELD_DESC = new TField("wikiLink", TType.STRING, 3)
  val BIRTHDATE_FIELD_DESC = new TField("birthDate", TType.I64, 4)
  val DEATHDATE_FIELD_DESC = new TField("deathDate", TType.I64, 5)

  val decoder = { (_iprot: TProtocol) =>
    var `fullName`: Option[String] = None
    var `alternateNames`: Seq[String] = null
    var `wikiLink`: Option[String] = None
    var `birthDate`: Option[Long] = None
    var `deathDate`: Option[Long] = None

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* fullName */
            _field.`type` match {
              case TType.STRING => {
                `fullName` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* alternateNames */
            _field.`type` match {
              case TType.LIST => {
                `alternateNames` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[String](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      _iprot.readString()
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 3 => { /* wikiLink */
            _field.`type` match {
              case TType.STRING => {
                `wikiLink` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 4 => { /* birthDate */
            _field.`type` match {
              case TType.I64 => {
                `birthDate` = Some{
                  _iprot.readI64()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 5 => { /* deathDate */
            _field.`type` match {
              case TType.I64 => {
                `deathDate` = Some{
                  _iprot.readI64()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    Person(`fullName`, `alternateNames`, `wikiLink`, `birthDate`, `deathDate`)
  }

  val encoder = { (_item: Person, _oproto: TProtocol) => _item.write(_oproto) }

}

case class Person(`fullName`: Option[String] = None, `alternateNames`: Seq[String], `wikiLink`: Option[String] = None, `birthDate`: Option[Long] = None, `deathDate`: Option[Long] = None) extends ThriftStruct {
  import Person._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`fullName`.isDefined) {
      val _item = `fullName`.get
      _oprot.writeFieldBegin(FULLNAME_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`alternateNames` ne null) {
      val _item = `alternateNames`
      _oprot.writeFieldBegin(ALTERNATENAMES_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.STRING, _item.size))
      _item.foreach { _item =>
        _oprot.writeString(_item)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    if (`wikiLink`.isDefined) {
      val _item = `wikiLink`.get
      _oprot.writeFieldBegin(WIKILINK_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`birthDate`.isDefined) {
      val _item = `birthDate`.get
      _oprot.writeFieldBegin(BIRTHDATE_FIELD_DESC)
      _oprot.writeI64(_item)
      _oprot.writeFieldEnd()
    }
    if (`deathDate`.isDefined) {
      val _item = `deathDate`.get
      _oprot.writeFieldBegin(DEATHDATE_FIELD_DESC)
      _oprot.writeI64(_item)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- Location

object Location extends ThriftStructCodec[Location] {
  val STRUCT_DESC = new TStruct("Location")
  val FULLNAME_FIELD_DESC = new TField("fullName", TType.STRING, 1)
  val ALTERNATENAMES_FIELD_DESC = new TField("alternateNames", TType.LIST, 2)
  val WIKILINK_FIELD_DESC = new TField("wikiLink", TType.STRING, 3)
  val LONGITUDE_FIELD_DESC = new TField("longitude", TType.DOUBLE, 4)
  val LATITUDE_FIELD_DESC = new TField("latitude", TType.DOUBLE, 5)

  val decoder = { (_iprot: TProtocol) =>
    var `fullName`: Option[String] = None
    var `alternateNames`: Seq[String] = null
    var `wikiLink`: Option[String] = None
    var `longitude`: Option[Double] = None
    var `latitude`: Option[Double] = None

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* fullName */
            _field.`type` match {
              case TType.STRING => {
                `fullName` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* alternateNames */
            _field.`type` match {
              case TType.LIST => {
                `alternateNames` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[String](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      _iprot.readString()
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 3 => { /* wikiLink */
            _field.`type` match {
              case TType.STRING => {
                `wikiLink` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 4 => { /* longitude */
            _field.`type` match {
              case TType.DOUBLE => {
                `longitude` = Some{
                  _iprot.readDouble()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 5 => { /* latitude */
            _field.`type` match {
              case TType.DOUBLE => {
                `latitude` = Some{
                  _iprot.readDouble()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    Location(`fullName`, `alternateNames`, `wikiLink`, `longitude`, `latitude`)
  }

  val encoder = { (_item: Location, _oproto: TProtocol) => _item.write(_oproto) }

}

case class Location(`fullName`: Option[String] = None, `alternateNames`: Seq[String], `wikiLink`: Option[String] = None, `longitude`: Option[Double] = None, `latitude`: Option[Double] = None) extends ThriftStruct {
  import Location._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`fullName`.isDefined) {
      val _item = `fullName`.get
      _oprot.writeFieldBegin(FULLNAME_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`alternateNames` ne null) {
      val _item = `alternateNames`
      _oprot.writeFieldBegin(ALTERNATENAMES_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.STRING, _item.size))
      _item.foreach { _item =>
        _oprot.writeString(_item)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    if (`wikiLink`.isDefined) {
      val _item = `wikiLink`.get
      _oprot.writeFieldBegin(WIKILINK_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`longitude`.isDefined) {
      val _item = `longitude`.get
      _oprot.writeFieldBegin(LONGITUDE_FIELD_DESC)
      _oprot.writeDouble(_item)
      _oprot.writeFieldEnd()
    }
    if (`latitude`.isDefined) {
      val _item = `latitude`.get
      _oprot.writeFieldBegin(LATITUDE_FIELD_DESC)
      _oprot.writeDouble(_item)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- ProteusObject

object ProteusObject extends ThriftStructCodec[ProteusObject] {
  val STRUCT_DESC = new TStruct("ProteusObject")
  val ID_FIELD_DESC = new TField("id", TType.STRUCT, 1)
  val TITLE_FIELD_DESC = new TField("title", TType.STRING, 2)
  val DESCRIPTION_FIELD_DESC = new TField("description", TType.STRING, 3)
  val IMGURL_FIELD_DESC = new TField("imgUrl", TType.STRING, 4)
  val THUMBURL_FIELD_DESC = new TField("thumbUrl", TType.STRING, 5)
  val EXTERNALURL_FIELD_DESC = new TField("externalUrl", TType.STRING, 6)
  val DATEFREQ_FIELD_DESC = new TField("dateFreq", TType.STRUCT, 7)
  val LANGUAGEMODEL_FIELD_DESC = new TField("languageModel", TType.STRUCT, 8)
  val LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 9)
  val COLLECTION_FIELD_DESC = new TField("collection", TType.STRUCT, 10)
  val PAGE_FIELD_DESC = new TField("page", TType.STRUCT, 11)
  val PICTURE_FIELD_DESC = new TField("picture", TType.STRUCT, 12)
  val VIDEO_FIELD_DESC = new TField("video", TType.STRUCT, 13)
  val AUDIO_FIELD_DESC = new TField("audio", TType.STRUCT, 14)
  val PERSON_FIELD_DESC = new TField("person", TType.STRUCT, 15)
  val LOCATION_FIELD_DESC = new TField("location", TType.STRUCT, 16)
  val ORGANIZATION_FIELD_DESC = new TField("organization", TType.STRUCT, 17)

  val decoder = { (_iprot: TProtocol) =>
    var `id`: AccessIdentifier = null
    var `title`: Option[String] = None
    var `description`: Option[String] = None
    var `imgUrl`: Option[String] = None
    var `thumbUrl`: Option[String] = None
    var `externalUrl`: Option[String] = None
    var `dateFreq`: Option[LongValueHistogram] = None
    var `languageModel`: Option[TermHistogram] = None
    var `language`: String = null
    var `collection`: Option[Collection] = None
    var `page`: Option[Page] = None
    var `picture`: Option[Picture] = None
    var `video`: Option[Video] = None
    var `audio`: Option[Audio] = None
    var `person`: Option[Person] = None
    var `location`: Option[Location] = None
    var `organization`: Option[Organization] = None

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* id */
            _field.`type` match {
              case TType.STRUCT => {
                `id` = {
                  AccessIdentifier.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* title */
            _field.`type` match {
              case TType.STRING => {
                `title` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 3 => { /* description */
            _field.`type` match {
              case TType.STRING => {
                `description` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 4 => { /* imgUrl */
            _field.`type` match {
              case TType.STRING => {
                `imgUrl` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 5 => { /* thumbUrl */
            _field.`type` match {
              case TType.STRING => {
                `thumbUrl` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 6 => { /* externalUrl */
            _field.`type` match {
              case TType.STRING => {
                `externalUrl` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 7 => { /* dateFreq */
            _field.`type` match {
              case TType.STRUCT => {
                `dateFreq` = Some{
                  LongValueHistogram.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 8 => { /* languageModel */
            _field.`type` match {
              case TType.STRUCT => {
                `languageModel` = Some{
                  TermHistogram.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 9 => { /* language */
            _field.`type` match {
              case TType.STRING => {
                `language` = {
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 10 => { /* collection */
            _field.`type` match {
              case TType.STRUCT => {
                `collection` = Some{
                  Collection.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 11 => { /* page */
            _field.`type` match {
              case TType.STRUCT => {
                `page` = Some{
                  Page.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 12 => { /* picture */
            _field.`type` match {
              case TType.STRUCT => {
                `picture` = Some{
                  Picture.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 13 => { /* video */
            _field.`type` match {
              case TType.STRUCT => {
                `video` = Some{
                  Video.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 14 => { /* audio */
            _field.`type` match {
              case TType.STRUCT => {
                `audio` = Some{
                  Audio.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 15 => { /* person */
            _field.`type` match {
              case TType.STRUCT => {
                `person` = Some{
                  Person.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 16 => { /* location */
            _field.`type` match {
              case TType.STRUCT => {
                `location` = Some{
                  Location.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 17 => { /* organization */
            _field.`type` match {
              case TType.STRUCT => {
                `organization` = Some{
                  Organization.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    ProteusObject(`id`, `title`, `description`, `imgUrl`, `thumbUrl`, `externalUrl`, `dateFreq`, `languageModel`, `language`, `collection`, `page`, `picture`, `video`, `audio`, `person`, `location`, `organization`)
  }

  val encoder = { (_item: ProteusObject, _oproto: TProtocol) => _item.write(_oproto) }

}

case class ProteusObject(`id`: AccessIdentifier, `title`: Option[String] = None, `description`: Option[String] = None, `imgUrl`: Option[String] = None, `thumbUrl`: Option[String] = None, `externalUrl`: Option[String] = None, `dateFreq`: Option[LongValueHistogram] = None, `languageModel`: Option[TermHistogram] = None, `language`: String = "en", `collection`: Option[Collection] = None, `page`: Option[Page] = None, `picture`: Option[Picture] = None, `video`: Option[Video] = None, `audio`: Option[Audio] = None, `person`: Option[Person] = None, `location`: Option[Location] = None, `organization`: Option[Organization] = None) extends ThriftStruct {
  import ProteusObject._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`id` ne null) {
      val _item = `id`
      _oprot.writeFieldBegin(ID_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`title`.isDefined) {
      val _item = `title`.get
      _oprot.writeFieldBegin(TITLE_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`description`.isDefined) {
      val _item = `description`.get
      _oprot.writeFieldBegin(DESCRIPTION_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`imgUrl`.isDefined) {
      val _item = `imgUrl`.get
      _oprot.writeFieldBegin(IMGURL_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`thumbUrl`.isDefined) {
      val _item = `thumbUrl`.get
      _oprot.writeFieldBegin(THUMBURL_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`externalUrl`.isDefined) {
      val _item = `externalUrl`.get
      _oprot.writeFieldBegin(EXTERNALURL_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`dateFreq`.isDefined) {
      val _item = `dateFreq`.get
      _oprot.writeFieldBegin(DATEFREQ_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`languageModel`.isDefined) {
      val _item = `languageModel`.get
      _oprot.writeFieldBegin(LANGUAGEMODEL_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`language` ne null) {
      val _item = `language`
      _oprot.writeFieldBegin(LANGUAGE_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`collection`.isDefined) {
      val _item = `collection`.get
      _oprot.writeFieldBegin(COLLECTION_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`page`.isDefined) {
      val _item = `page`.get
      _oprot.writeFieldBegin(PAGE_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`picture`.isDefined) {
      val _item = `picture`.get
      _oprot.writeFieldBegin(PICTURE_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`video`.isDefined) {
      val _item = `video`.get
      _oprot.writeFieldBegin(VIDEO_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`audio`.isDefined) {
      val _item = `audio`.get
      _oprot.writeFieldBegin(AUDIO_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`person`.isDefined) {
      val _item = `person`.get
      _oprot.writeFieldBegin(PERSON_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`location`.isDefined) {
      val _item = `location`.get
      _oprot.writeFieldBegin(LOCATION_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`organization`.isDefined) {
      val _item = `organization`.get
      _oprot.writeFieldBegin(ORGANIZATION_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- TransformRequest

object TransformRequest extends ThriftStructCodec[TransformRequest] {
  val STRUCT_DESC = new TStruct("TransformRequest")
  val TRANSFORMTYPE_FIELD_DESC = new TField("transformType", TType.I32, 1)
  val REFERENCEID_FIELD_DESC = new TField("referenceId", TType.STRUCT, 2)
  val TARGETTYPE_FIELD_DESC = new TField("targetType", TType.I32, 3)
  val PARAMS_FIELD_DESC = new TField("params", TType.STRUCT, 4)
  val TERM_FIELD_DESC = new TField("term", TType.STRING, 5)
  val RADIUSINMILES_FIELD_DESC = new TField("radiusInMiles", TType.I32, 6)

  val decoder = { (_iprot: TProtocol) =>
    var `transformType`: TransformType = null
    var `referenceId`: AccessIdentifier = null
    var `targetType`: Option[ProteusType] = None
    var `params`: Option[RequestParameters] = None
    var `term`: Option[String] = None
    var `radiusInMiles`: Option[Int] = None

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* transformType */
            _field.`type` match {
              case TType.I32 => {
                `transformType` = {
                  TransformType(_iprot.readI32())
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 2 => { /* referenceId */
            _field.`type` match {
              case TType.STRUCT => {
                `referenceId` = {
                  AccessIdentifier.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 3 => { /* targetType */
            _field.`type` match {
              case TType.I32 => {
                `targetType` = Some{
                  ProteusType(_iprot.readI32())
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 4 => { /* params */
            _field.`type` match {
              case TType.STRUCT => {
                `params` = Some{
                  RequestParameters.decoder(_iprot)
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 5 => { /* term */
            _field.`type` match {
              case TType.STRING => {
                `term` = Some{
                  _iprot.readString()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case 6 => { /* radiusInMiles */
            _field.`type` match {
              case TType.I32 => {
                `radiusInMiles` = Some{
                  _iprot.readI32()
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    TransformRequest(`transformType`, `referenceId`, `targetType`, `params`, `term`, `radiusInMiles`)
  }

  val encoder = { (_item: TransformRequest, _oproto: TProtocol) => _item.write(_oproto) }

}

case class TransformRequest(`transformType`: TransformType, `referenceId`: AccessIdentifier, `targetType`: Option[ProteusType] = None, `params`: Option[RequestParameters] = None, `term`: Option[String] = None, `radiusInMiles`: Option[Int] = Some(10)) extends ThriftStruct {
  import TransformRequest._

  def radiusInMilesOrDefault = radiusInMiles getOrElse 10

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`transformType` ne null) {
      val _item = `transformType`
      _oprot.writeFieldBegin(TRANSFORMTYPE_FIELD_DESC)
      _oprot.writeI32(_item.value)
      _oprot.writeFieldEnd()
    }
    if (`referenceId` ne null) {
      val _item = `referenceId`
      _oprot.writeFieldBegin(REFERENCEID_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`targetType`.isDefined) {
      val _item = `targetType`.get
      _oprot.writeFieldBegin(TARGETTYPE_FIELD_DESC)
      _oprot.writeI32(_item.value)
      _oprot.writeFieldEnd()
    }
    if (`params`.isDefined) {
      val _item = `params`.get
      _oprot.writeFieldBegin(PARAMS_FIELD_DESC)
      _item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (`term`.isDefined) {
      val _item = `term`.get
      _oprot.writeFieldBegin(TERM_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    if (`radiusInMiles`.isDefined) {
      val _item = `radiusInMiles`.get
      _oprot.writeFieldBegin(RADIUSINMILES_FIELD_DESC)
      _oprot.writeI32(_item)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- TransformResponse

object TransformResponse extends ThriftStructCodec[TransformResponse] {
  val STRUCT_DESC = new TStruct("TransformResponse")
  val OBJECTS_FIELD_DESC = new TField("objects", TType.LIST, 1)

  val decoder = { (_iprot: TProtocol) =>
    var `objects`: Seq[ProteusObject] = null

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* objects */
            _field.`type` match {
              case TType.LIST => {
                `objects` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[ProteusObject](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      ProteusObject.decoder(_iprot)
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    TransformResponse(`objects`)
  }

  val encoder = { (_item: TransformResponse, _oproto: TProtocol) => _item.write(_oproto) }

}

case class TransformResponse(`objects`: Seq[ProteusObject]) extends ThriftStruct {
  import TransformResponse._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`objects` ne null) {
      val _item = `objects`
      _oprot.writeFieldBegin(OBJECTS_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.STRUCT, _item.size))
      _item.foreach { _item =>
        _item.write(_oprot)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- LookupRequest

object LookupRequest extends ThriftStructCodec[LookupRequest] {
  val STRUCT_DESC = new TStruct("LookupRequest")
  val ID_FIELD_DESC = new TField("id", TType.LIST, 1)

  val decoder = { (_iprot: TProtocol) =>
    var `id`: Seq[AccessIdentifier] = null

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* id */
            _field.`type` match {
              case TType.LIST => {
                `id` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[AccessIdentifier](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      AccessIdentifier.decoder(_iprot)
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    LookupRequest(`id`)
  }

  val encoder = { (_item: LookupRequest, _oproto: TProtocol) => _item.write(_oproto) }

}

case class LookupRequest(`id`: Seq[AccessIdentifier]) extends ThriftStruct {
  import LookupRequest._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`id` ne null) {
      val _item = `id`
      _oprot.writeFieldBegin(ID_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.STRUCT, _item.size))
      _item.foreach { _item =>
        _item.write(_oprot)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- LookupResponse

object LookupResponse extends ThriftStructCodec[LookupResponse] {
  val STRUCT_DESC = new TStruct("LookupResponse")
  val OBJECTS_FIELD_DESC = new TField("objects", TType.LIST, 1)

  val decoder = { (_iprot: TProtocol) =>
    var `objects`: Seq[ProteusObject] = null

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* objects */
            _field.`type` match {
              case TType.LIST => {
                `objects` = {
                  val _list = _iprot.readListBegin()
                  val _rv = new mutable.ArrayBuffer[ProteusObject](_list.size)
                  var _i = 0
                  while (_i < _list.size) {
                    _rv += {
                      ProteusObject.decoder(_iprot)
                    }
                    _i += 1
                  }
                  _iprot.readListEnd()
                  _rv.toSeq
                }
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    LookupResponse(`objects`)
  }

  val encoder = { (_item: LookupResponse, _oproto: TProtocol) => _item.write(_oproto) }

}

case class LookupResponse(`objects`: Seq[ProteusObject]) extends ThriftStruct {
  import LookupResponse._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`objects` ne null) {
      val _item = `objects`
      _oprot.writeFieldBegin(OBJECTS_FIELD_DESC)
      _oprot.writeListBegin(new TList(TType.STRUCT, _item.size))
      _item.foreach { _item =>
        _item.write(_oprot)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- ProteusProvider

object ProteusProvider {
  trait Iface {
    def search(`srequest`: SearchRequest): SearchResponse

    def lookup(`lrequest`: LookupRequest): LookupResponse

    def transform(`trequest`: TransformRequest): TransformResponse
  }

  trait FutureIface {
    def search(`srequest`: SearchRequest): Future[SearchResponse]

    def lookup(`lrequest`: LookupRequest): Future[LookupResponse]

    def transform(`trequest`: TransformRequest): Future[TransformResponse]
  }

  // ----- search_args
  
  object search_args extends ThriftStructCodec[search_args] {
    val STRUCT_DESC = new TStruct("search_args")
    val SREQUEST_FIELD_DESC = new TField("srequest", TType.STRUCT, 1)
  
    val decoder = { (_iprot: TProtocol) =>
      var `srequest`: SearchRequest = null
  
      var _field: TField = null
      var _done = false
      _iprot.readStructBegin()
      while (!_done) {
        _field = _iprot.readFieldBegin
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 => { /* srequest */
              _field.`type` match {
                case TType.STRUCT => {
                  `srequest` = {
                    SearchRequest.decoder(_iprot)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case _ => TProtocolUtil.skip(_iprot, _field.`type`)
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
      search_args(`srequest`)
    }
  
    val encoder = { (_item: search_args, _oproto: TProtocol) => _item.write(_oproto) }
  
  }
  
  case class search_args(`srequest`: SearchRequest) extends ThriftStruct {
    import search_args._
  
    override def write(_oprot: TProtocol) {
      validate()
      _oprot.writeStructBegin(STRUCT_DESC)
      if (`srequest` ne null) {
        val _item = `srequest`
        _oprot.writeFieldBegin(SREQUEST_FIELD_DESC)
        _item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def validate() = true //TODO: Implement this
  
  }

  // ----- search_result
  
  object search_result extends ThriftStructCodec[search_result] {
    val STRUCT_DESC = new TStruct("search_result")
    val SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0)
  
    val decoder = { (_iprot: TProtocol) =>
      var `success`: Option[SearchResponse] = None
  
      var _field: TField = null
      var _done = false
      _iprot.readStructBegin()
      while (!_done) {
        _field = _iprot.readFieldBegin
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 => { /* success */
              _field.`type` match {
                case TType.STRUCT => {
                  `success` = Some{
                    SearchResponse.decoder(_iprot)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case _ => TProtocolUtil.skip(_iprot, _field.`type`)
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
      search_result(`success`)
    }
  
    val encoder = { (_item: search_result, _oproto: TProtocol) => _item.write(_oproto) }
  
  }
  
  case class search_result(`success`: Option[SearchResponse] = None) extends ThriftStruct {
    import search_result._
  
    override def write(_oprot: TProtocol) {
      validate()
      _oprot.writeStructBegin(STRUCT_DESC)
      if (`success`.isDefined) {
        val _item = `success`.get
        _oprot.writeFieldBegin(SUCCESS_FIELD_DESC)
        _item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def validate() = true //TODO: Implement this
  
  }

  // ----- lookup_args
  
  object lookup_args extends ThriftStructCodec[lookup_args] {
    val STRUCT_DESC = new TStruct("lookup_args")
    val LREQUEST_FIELD_DESC = new TField("lrequest", TType.STRUCT, 2)
  
    val decoder = { (_iprot: TProtocol) =>
      var `lrequest`: LookupRequest = null
  
      var _field: TField = null
      var _done = false
      _iprot.readStructBegin()
      while (!_done) {
        _field = _iprot.readFieldBegin
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 2 => { /* lrequest */
              _field.`type` match {
                case TType.STRUCT => {
                  `lrequest` = {
                    LookupRequest.decoder(_iprot)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case _ => TProtocolUtil.skip(_iprot, _field.`type`)
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
      lookup_args(`lrequest`)
    }
  
    val encoder = { (_item: lookup_args, _oproto: TProtocol) => _item.write(_oproto) }
  
  }
  
  case class lookup_args(`lrequest`: LookupRequest) extends ThriftStruct {
    import lookup_args._
  
    override def write(_oprot: TProtocol) {
      validate()
      _oprot.writeStructBegin(STRUCT_DESC)
      if (`lrequest` ne null) {
        val _item = `lrequest`
        _oprot.writeFieldBegin(LREQUEST_FIELD_DESC)
        _item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def validate() = true //TODO: Implement this
  
  }

  // ----- lookup_result
  
  object lookup_result extends ThriftStructCodec[lookup_result] {
    val STRUCT_DESC = new TStruct("lookup_result")
    val SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0)
  
    val decoder = { (_iprot: TProtocol) =>
      var `success`: Option[LookupResponse] = None
  
      var _field: TField = null
      var _done = false
      _iprot.readStructBegin()
      while (!_done) {
        _field = _iprot.readFieldBegin
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 => { /* success */
              _field.`type` match {
                case TType.STRUCT => {
                  `success` = Some{
                    LookupResponse.decoder(_iprot)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case _ => TProtocolUtil.skip(_iprot, _field.`type`)
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
      lookup_result(`success`)
    }
  
    val encoder = { (_item: lookup_result, _oproto: TProtocol) => _item.write(_oproto) }
  
  }
  
  case class lookup_result(`success`: Option[LookupResponse] = None) extends ThriftStruct {
    import lookup_result._
  
    override def write(_oprot: TProtocol) {
      validate()
      _oprot.writeStructBegin(STRUCT_DESC)
      if (`success`.isDefined) {
        val _item = `success`.get
        _oprot.writeFieldBegin(SUCCESS_FIELD_DESC)
        _item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def validate() = true //TODO: Implement this
  
  }

  // ----- transform_args
  
  object transform_args extends ThriftStructCodec[transform_args] {
    val STRUCT_DESC = new TStruct("transform_args")
    val TREQUEST_FIELD_DESC = new TField("trequest", TType.STRUCT, 3)
  
    val decoder = { (_iprot: TProtocol) =>
      var `trequest`: TransformRequest = null
  
      var _field: TField = null
      var _done = false
      _iprot.readStructBegin()
      while (!_done) {
        _field = _iprot.readFieldBegin
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 3 => { /* trequest */
              _field.`type` match {
                case TType.STRUCT => {
                  `trequest` = {
                    TransformRequest.decoder(_iprot)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case _ => TProtocolUtil.skip(_iprot, _field.`type`)
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
      transform_args(`trequest`)
    }
  
    val encoder = { (_item: transform_args, _oproto: TProtocol) => _item.write(_oproto) }
  
  }
  
  case class transform_args(`trequest`: TransformRequest) extends ThriftStruct {
    import transform_args._
  
    override def write(_oprot: TProtocol) {
      validate()
      _oprot.writeStructBegin(STRUCT_DESC)
      if (`trequest` ne null) {
        val _item = `trequest`
        _oprot.writeFieldBegin(TREQUEST_FIELD_DESC)
        _item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def validate() = true //TODO: Implement this
  
  }

  // ----- transform_result
  
  object transform_result extends ThriftStructCodec[transform_result] {
    val STRUCT_DESC = new TStruct("transform_result")
    val SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0)
  
    val decoder = { (_iprot: TProtocol) =>
      var `success`: Option[TransformResponse] = None
  
      var _field: TField = null
      var _done = false
      _iprot.readStructBegin()
      while (!_done) {
        _field = _iprot.readFieldBegin
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 => { /* success */
              _field.`type` match {
                case TType.STRUCT => {
                  `success` = Some{
                    TransformResponse.decoder(_iprot)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case _ => TProtocolUtil.skip(_iprot, _field.`type`)
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
      transform_result(`success`)
    }
  
    val encoder = { (_item: transform_result, _oproto: TProtocol) => _item.write(_oproto) }
  
  }
  
  case class transform_result(`success`: Option[TransformResponse] = None) extends ThriftStruct {
    import transform_result._
  
    override def write(_oprot: TProtocol) {
      validate()
      _oprot.writeStructBegin(STRUCT_DESC)
      if (`success`.isDefined) {
        val _item = `success`.get
        _oprot.writeFieldBegin(SUCCESS_FIELD_DESC)
        _item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def validate() = true //TODO: Implement this
  
  }

  // ----- finagle client
  
  import com.twitter.finagle.{Service => FinagleService}
  import com.twitter.finagle.stats.{NullStatsReceiver, StatsReceiver}
  import com.twitter.finagle.thrift.ThriftClientRequest
  import com.twitter.scrooge.FinagleThriftClient
  
  class FinagledClient(
    val service: FinagleService[ThriftClientRequest, Array[Byte]],
    val protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
    override val serviceName: Option[String] = None,
    stats: StatsReceiver = NullStatsReceiver
  ) extends FinagleThriftClient with FutureIface {
    private[this] val scopedStats = serviceName map { stats.scope(_) } getOrElse stats
    private[this] val _searchScope = scopedStats.scope("search")
    private[this] val _searchRequestsCounter = _searchScope.counter("requests")
    private[this] val _searchSuccessCounter = _searchScope.counter("success")
    private[this] val _searchFailuresCounter = _searchScope.counter("failures")
    private[this] val _searchFailuresScope = _searchScope.scope("failures")
    
    def search(`srequest`: SearchRequest): Future[SearchResponse] = {
      _searchRequestsCounter.incr()
      encodeRequest("search", search_args(srequest)) flatMap { this.service } flatMap {
        decodeResponse(_, search_result.decoder)
      } flatMap { result =>
        { result.success.map(Future.value) getOrElse missingResult("search") }
      } rescue {
        case ex: SourcedException =>
          this.serviceName foreach { ex.serviceName = _ }
          Future.exception(ex)
      } onSuccess { _ =>
        _searchSuccessCounter.incr()
      } onFailure { ex =>
        _searchFailuresCounter.incr()
        _searchFailuresScope.counter(ex.getClass.getName).incr()
      }
    }
  
    private[this] val _lookupScope = scopedStats.scope("lookup")
    private[this] val _lookupRequestsCounter = _lookupScope.counter("requests")
    private[this] val _lookupSuccessCounter = _lookupScope.counter("success")
    private[this] val _lookupFailuresCounter = _lookupScope.counter("failures")
    private[this] val _lookupFailuresScope = _lookupScope.scope("failures")
    
    def lookup(`lrequest`: LookupRequest): Future[LookupResponse] = {
      _lookupRequestsCounter.incr()
      encodeRequest("lookup", lookup_args(lrequest)) flatMap { this.service } flatMap {
        decodeResponse(_, lookup_result.decoder)
      } flatMap { result =>
        { result.success.map(Future.value) getOrElse missingResult("lookup") }
      } rescue {
        case ex: SourcedException =>
          this.serviceName foreach { ex.serviceName = _ }
          Future.exception(ex)
      } onSuccess { _ =>
        _lookupSuccessCounter.incr()
      } onFailure { ex =>
        _lookupFailuresCounter.incr()
        _lookupFailuresScope.counter(ex.getClass.getName).incr()
      }
    }
  
    private[this] val _transformScope = scopedStats.scope("transform")
    private[this] val _transformRequestsCounter = _transformScope.counter("requests")
    private[this] val _transformSuccessCounter = _transformScope.counter("success")
    private[this] val _transformFailuresCounter = _transformScope.counter("failures")
    private[this] val _transformFailuresScope = _transformScope.scope("failures")
    
    def transform(`trequest`: TransformRequest): Future[TransformResponse] = {
      _transformRequestsCounter.incr()
      encodeRequest("transform", transform_args(trequest)) flatMap { this.service } flatMap {
        decodeResponse(_, transform_result.decoder)
      } flatMap { result =>
        { result.success.map(Future.value) getOrElse missingResult("transform") }
      } rescue {
        case ex: SourcedException =>
          this.serviceName foreach { ex.serviceName = _ }
          Future.exception(ex)
      } onSuccess { _ =>
        _transformSuccessCounter.incr()
      } onFailure { ex =>
        _transformFailuresCounter.incr()
        _transformFailuresScope.counter(ex.getClass.getName).incr()
      }
    }
  
  }

  // ----- finagle service
  
  import com.twitter.scrooge.FinagleThriftService
  
  class FinagledService(
    iface: FutureIface,
    val protocolFactory: TProtocolFactory
  ) extends FinagleThriftService {
    functionMap("search") = { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = search_args.decoder(iprot)
        iprot.readMessageEnd()
        (try {
          iface.search(args.srequest)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: SearchResponse =>
          reply("search", seqid, search_result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("search", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    }
  
    functionMap("lookup") = { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = lookup_args.decoder(iprot)
        iprot.readMessageEnd()
        (try {
          iface.lookup(args.lrequest)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: LookupResponse =>
          reply("lookup", seqid, lookup_result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("lookup", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    }
  
    functionMap("transform") = { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = transform_args.decoder(iprot)
        iprot.readMessageEnd()
        (try {
          iface.transform(args.trequest)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: TransformResponse =>
          reply("transform", seqid, transform_result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("transform", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    }
  
  }

  // ----- ostrich service
  
  import com.twitter.finagle.builder.{Server, ServerBuilder}
  import com.twitter.finagle.stats.{StatsReceiver, OstrichStatsReceiver}
  import com.twitter.finagle.thrift.ThriftServerFramedCodec
  import com.twitter.finagle.tracing.{NullTracer, Tracer}
  import com.twitter.logging.Logger
  import com.twitter.ostrich.admin.Service
  
  trait ThriftServer extends Service with FutureIface {
    val log = Logger.get(getClass)
  
    def thriftCodec = ThriftServerFramedCodec()
    def statsReceiver: StatsReceiver = new OstrichStatsReceiver
    def tracerFactory: Tracer.Factory = NullTracer.factory
    val thriftProtocolFactory: TProtocolFactory = new TBinaryProtocol.Factory()
    val thriftPort: Int
    val serverName: String
  
    var server: Server = null
  
    def start() {
      val thriftImpl = new FinagledService(this, thriftProtocolFactory)
      server = serverBuilder.build(thriftImpl)
    }
  
    /**
     * You can override this to provide additional configuration
     * to the ServerBuilder.
     */
    def serverBuilder =
      ServerBuilder()
        .codec(thriftCodec)
        .name(serverName)
        .reportTo(statsReceiver)
        .bindTo(new InetSocketAddress(thriftPort))
        .tracerFactory(tracerFactory)
  
    def shutdown() {
      synchronized {
        if (server != null) {
          server.close(0.seconds)
        }
      }
    }
  }

}

