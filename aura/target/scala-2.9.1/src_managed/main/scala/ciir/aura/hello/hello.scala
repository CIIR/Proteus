/**
 * Autogenerated by Scrooge
 * Edit this shit, I dare you.
 */

package ciir.aura.hello

import java.net.InetSocketAddress
import java.nio.ByteBuffer
import java.util.Arrays
import scala.collection.{Map, Set}
import scala.collection.mutable
import com.twitter.conversions.time._
import com.twitter.finagle.SourcedException
import com.twitter.scrooge.{ThriftStruct, ThriftStructCodec}
import com.twitter.util.Future
import org.apache.thrift.TApplicationException
import org.apache.thrift.TEnum
import org.apache.thrift.protocol._
import org.apache.thrift.transport.{TMemoryInputTransport, TMemoryBuffer}

// ----- HelloMsg

object HelloMsg extends ThriftStructCodec[HelloMsg] {
  val STRUCT_DESC = new TStruct("HelloMsg")
  val NAME_FIELD_DESC = new TField("name", TType.STRING, 1)

  val decoder = { (_iprot: TProtocol) =>
    var `name`: String = null
    var _got_name = false

    var _field: TField = null
    var _done = false
    _iprot.readStructBegin()
    while (!_done) {
      _field = _iprot.readFieldBegin
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => { /* name */
            _field.`type` match {
              case TType.STRING => {
                `name` = {
                  _iprot.readString()
                }
                _got_name = true
              }
              case _ => TProtocolUtil.skip(_iprot, _field.`type`)
            }
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()
    if (!_got_name) throw new TProtocolException("Required field 'name' was not found in serialized data for struct HelloMsg")
    HelloMsg(`name`)
  }

  val encoder = { (_item: HelloMsg, _oproto: TProtocol) => _item.write(_oproto) }

}

case class HelloMsg(`name`: String) extends ThriftStruct {
  import HelloMsg._

  override def write(_oprot: TProtocol) {
    validate()
    _oprot.writeStructBegin(STRUCT_DESC)
    if (`name` ne null) {
      val _item = `name`
      _oprot.writeFieldBegin(NAME_FIELD_DESC)
      _oprot.writeString(_item)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this

}

// ----- HelloService

object HelloService {
  trait Iface {
    def sayHello(`msg`: HelloMsg): String
  }

  trait FutureIface {
    def sayHello(`msg`: HelloMsg): Future[String]
  }

  // ----- sayHello_args
  
  object sayHello_args extends ThriftStructCodec[sayHello_args] {
    val STRUCT_DESC = new TStruct("sayHello_args")
    val MSG_FIELD_DESC = new TField("msg", TType.STRUCT, 1)
  
    val decoder = { (_iprot: TProtocol) =>
      var `msg`: HelloMsg = null
  
      var _field: TField = null
      var _done = false
      _iprot.readStructBegin()
      while (!_done) {
        _field = _iprot.readFieldBegin
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 => { /* msg */
              _field.`type` match {
                case TType.STRUCT => {
                  `msg` = {
                    HelloMsg.decoder(_iprot)
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case _ => TProtocolUtil.skip(_iprot, _field.`type`)
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
      sayHello_args(`msg`)
    }
  
    val encoder = { (_item: sayHello_args, _oproto: TProtocol) => _item.write(_oproto) }
  
  }
  
  case class sayHello_args(`msg`: HelloMsg) extends ThriftStruct {
    import sayHello_args._
  
    override def write(_oprot: TProtocol) {
      validate()
      _oprot.writeStructBegin(STRUCT_DESC)
      if (`msg` ne null) {
        val _item = `msg`
        _oprot.writeFieldBegin(MSG_FIELD_DESC)
        _item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def validate() = true //TODO: Implement this
  
  }

  // ----- sayHello_result
  
  object sayHello_result extends ThriftStructCodec[sayHello_result] {
    val STRUCT_DESC = new TStruct("sayHello_result")
    val SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0)
  
    val decoder = { (_iprot: TProtocol) =>
      var `success`: Option[String] = None
  
      var _field: TField = null
      var _done = false
      _iprot.readStructBegin()
      while (!_done) {
        _field = _iprot.readFieldBegin
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 => { /* success */
              _field.`type` match {
                case TType.STRING => {
                  `success` = Some{
                    _iprot.readString()
                  }
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case _ => TProtocolUtil.skip(_iprot, _field.`type`)
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
      sayHello_result(`success`)
    }
  
    val encoder = { (_item: sayHello_result, _oproto: TProtocol) => _item.write(_oproto) }
  
  }
  
  case class sayHello_result(`success`: Option[String] = None) extends ThriftStruct {
    import sayHello_result._
  
    override def write(_oprot: TProtocol) {
      validate()
      _oprot.writeStructBegin(STRUCT_DESC)
      if (`success`.isDefined) {
        val _item = `success`.get
        _oprot.writeFieldBegin(SUCCESS_FIELD_DESC)
        _oprot.writeString(_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def validate() = true //TODO: Implement this
  
  }

  // ----- finagle client
  
  import com.twitter.finagle.{Service => FinagleService}
  import com.twitter.finagle.stats.{NullStatsReceiver, StatsReceiver}
  import com.twitter.finagle.thrift.ThriftClientRequest
  import com.twitter.scrooge.FinagleThriftClient
  
  class FinagledClient(
    val service: FinagleService[ThriftClientRequest, Array[Byte]],
    val protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
    override val serviceName: Option[String] = None,
    stats: StatsReceiver = NullStatsReceiver
  ) extends FinagleThriftClient with FutureIface {
    private[this] val scopedStats = serviceName map { stats.scope(_) } getOrElse stats
    private[this] val _sayHelloScope = scopedStats.scope("sayHello")
    private[this] val _sayHelloRequestsCounter = _sayHelloScope.counter("requests")
    private[this] val _sayHelloSuccessCounter = _sayHelloScope.counter("success")
    private[this] val _sayHelloFailuresCounter = _sayHelloScope.counter("failures")
    private[this] val _sayHelloFailuresScope = _sayHelloScope.scope("failures")
    
    def sayHello(`msg`: HelloMsg): Future[String] = {
      _sayHelloRequestsCounter.incr()
      encodeRequest("sayHello", sayHello_args(msg)) flatMap { this.service } flatMap {
        decodeResponse(_, sayHello_result.decoder)
      } flatMap { result =>
        { result.success.map(Future.value) getOrElse missingResult("sayHello") }
      } rescue {
        case ex: SourcedException =>
          this.serviceName foreach { ex.serviceName = _ }
          Future.exception(ex)
      } onSuccess { _ =>
        _sayHelloSuccessCounter.incr()
      } onFailure { ex =>
        _sayHelloFailuresCounter.incr()
        _sayHelloFailuresScope.counter(ex.getClass.getName).incr()
      }
    }
  
  }

  // ----- finagle service
  
  import com.twitter.scrooge.FinagleThriftService
  
  class FinagledService(
    iface: FutureIface,
    val protocolFactory: TProtocolFactory
  ) extends FinagleThriftService {
    functionMap("sayHello") = { (iprot: TProtocol, seqid: Int) =>
      try {
        val args = sayHello_args.decoder(iprot)
        iprot.readMessageEnd()
        (try {
          iface.sayHello(args.msg)
        } catch {
          case e: Exception => Future.exception(e)
        }) flatMap { value: String =>
          reply("sayHello", seqid, sayHello_result(success = Some(value)))
        } rescue {
          case e => Future.exception(e)
        }
      } catch {
        case e: TProtocolException => {
          iprot.readMessageEnd()
          exception("sayHello", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
        }
        case e: Exception => Future.exception(e)
      }
    }
  
  }

  // ----- ostrich service
  
  import com.twitter.finagle.builder.{Server, ServerBuilder}
  import com.twitter.finagle.stats.{StatsReceiver, OstrichStatsReceiver}
  import com.twitter.finagle.thrift.ThriftServerFramedCodec
  import com.twitter.finagle.tracing.{NullTracer, Tracer}
  import com.twitter.logging.Logger
  import com.twitter.ostrich.admin.Service
  
  trait ThriftServer extends Service with FutureIface {
    val log = Logger.get(getClass)
  
    def thriftCodec = ThriftServerFramedCodec()
    def statsReceiver: StatsReceiver = new OstrichStatsReceiver
    def tracerFactory: Tracer.Factory = NullTracer.factory
    val thriftProtocolFactory: TProtocolFactory = new TBinaryProtocol.Factory()
    val thriftPort: Int
    val serverName: String
  
    var server: Server = null
  
    def start() {
      val thriftImpl = new FinagledService(this, thriftProtocolFactory)
      server = serverBuilder.build(thriftImpl)
    }
  
    /**
     * You can override this to provide additional configuration
     * to the ServerBuilder.
     */
    def serverBuilder =
      ServerBuilder()
        .codec(thriftCodec)
        .name(serverName)
        .reportTo(statsReceiver)
        .bindTo(new InetSocketAddress(thriftPort))
        .tracerFactory(tracerFactory)
  
    def shutdown() {
      synchronized {
        if (server != null) {
          server.close(0.seconds)
        }
      }
    }
  }

}

